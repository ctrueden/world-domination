Save & load game state to disk
 - use XStream: http://xstream.codehaus.org/ - either JSON or XML

game runs in a single JVM as a server
clients transmit commands to the server via sockets over localhost
game state is abstracted from client rendering
so we can have e.g. a BBS/Door client, and a web client
think about this more, and look for useful tools to help
 - maybe server should simply support multiple output protocols
 - learn about AJAX to evaluate how web client's output protocol would work
 - other possible clients: applet, instant messaging, IRC, CLI

GameServer
 - manages ClientConnections with clients
 - protocol used is abstracted from server
 - SocketProtocol is the initial one i'll implement
 - but maybe we'll add XML-RPC protocol, etc., later

DataProtocol
 - interface for communication using a particular protocol
 - methods:
  + void send(String)
  + char receive()

ClientConnection
 - represents connection to a specific client
 - calls protocol.receive() whenever a character is received
 - server calls protocol.send(String) as appropriate
  + often in response to user input from receive
  + but sometimes in response to other client's actions
  + sometimes in response to time elapsing as well (e.g., connection timeout)

Character
 - base class holding details common to PCs and NPCs
 - instance of this class represents a PC or NPC
 - PCs are controlled by a player, of course
 - NPCs can be townsfolk, vassals, lords, monsters, ...
  + some modules have NPCs associated with them; e.g.:
   * the tavern has a bartender
   * every town has an old man
   * captain of the guard
   * governor of the province
   * many more
 - fields:
  + player - name of the character's player, or null for an NPC - string
  + name - name of the character - string
  + race - enum
  + gender - enum
  + age - integer
  + class - enum
   * can be one of the normally accessible PC classes,
   * or a monster class,
   * or a special class
  + level - integer
  + stats (level & class driven) - integers
   * strength
   * vitality
   * speed
   * stealth
   * skill
   * magic
   * faith
   * luck
   * charm
   * leadership (?)
   * current/max HP/MP/etc.
  + stats (action & situation driven) - integers
   * honor
   * fame
   * renown
  + current location - Province
  + gear/items - list of Items?
  + equipment
   * weapon - Item
   * armor - Item
   * shield - Item
   * accessory - Item
   * etc. - more Items
  + spells - list of Spells known?
  + lord - Character to whom this character currently owes allegiance, if any
   * could be a PC or an NPC
   * e.g., if you sell your soul to Satan, it will be Satan (an NPC)
  + provincesGoverned - list of Provinces this character governs
  + provincesOwned - list of Provinces the character owns
  + 
 - methods to manipulate these fields
 - derived stats are not fields, but have methods that compute from the fields
  + attack - based on strength & weaponry
  + defense - based on vitality & armor
  + hit%, crit% - based on skill & luck (3 attack results: miss, hit & crit)
  + evade% - based on speed, stealth & luck

Province
 - class holding details about provinces
 - instance of class represents a particular province
 - fields:
  + name - string
  + modules - list of Modules
  + owner - Character, or null if no one controls it
  + governor - Character, or null if no one governs

World
 - class holding details about the geographical configuration of the world
 - fields:
  + provinces - list of Provinces
  + TODO finish listing these

Game
 - has pointers to the entire game state (the World, all Characters, etc.)
 - serialized to/from disk with XStream as XML

Module
 - base class for describing a particular piece of the game
 - subclass describes a particular module, such as one of the world wonders
 - some modules need the flexibility to input and output whatever they want,
   whenever they want
  + many leaf modules
  + combat module
 - base module design is such that the "active" module for a particular client
   indicates which piece of the game is currently handling their I/O
 - game server just passes I/O through the active module
 - methods:
  - input()
  - output()
 - modules can reference other modules
 - the game starts out pointing at the Login module

Menu
 - extends Module
 - many areas have a very similar pattern: a description followed
   by a series of menu choices; MenuModule class encompasses those
 - fields:
  + name - string
  + description - overview printed when you first select the module
  + modules - list of sub modules accessible from this one

Place
 - extends Menu
 - "Places to go"
 - all places have a few things in common
  + can "burn the place down" or ("torch the place" if pyrokineticist)
  + there is a proprietor
   - can talk to them
   - can see their stats (maybe only some classes)
   - can challenge them to a duel
   - can try to murder them in their sleep
 - example buildings:
  + wonder of the world
  + pawn shop
  + royal palace
  + tavern/inn
  + blacksmith
  + weapon shop
  + armor shop
  + item shop
  + magic shop
  + accessory shop
  + brothel/whorehouse
  + bounty house
  + assassin's guild
  + other guilds?
  + church
  + barracks
  + bank

Person
 - extends Menu
 - "People to see"
 - example people:
  + the Old Man
  + Rumor mongers
  + the "black cloaked figure" (gets you into assassin's guild)
  + psionic messenger

Action
 - extends Module
 - "Things to do"
 - example actions:
  + Send message to another player (only if psionic)
  + Use ability (maybe should enumerate these based on class instead)
  + Slay mighty beasts
  + Pity foo
  + Hunt someone down
  + View your stats
  + See world map
  + Travel to another province
  + Read daily events

FieldUnitType
 - class for describing a particular unit type of an army
 - one instance per field unit type
 - fields:
  + name - string (e.g., 'footmen', 'pixies', 'trolls')
  + melee - integer
  + ranged - integer
  + max HP - integer
 - first round of combat, armies deal each other ranged damage
 - then armies close and deal melee on subsequent rounds
 - damage is divided by % according to number of each type of unit
 - consider heal type units
 - heroes do not take damage from enemy army until allied army is defeated
 - heroes damage enemy army based on their stats

FieldUnit
 - class for an actual group of field units (e.g., 530 Knights)
 - fields:
  + type - FieldUnitType
  + count - number of units in the squad - integer
  + cur HP - list of current HP values

FieldSquad
 - class for a squad of various field units (e.g., 50 Knights + 20 Pixies)
 - fields:
  + nickname - string (e.g., 'trollinators', 'doomsday squad')
  + units - list of FieldUnits

wonders of the world:
 - well of knowledge
 - fountain of youth
 - well of magic
 - well of faith
 - well of shadows
 - well of strength
 - well of rebirth
 - cave of the red dragon
 - the all-seeing oracle
 - cliffs of enlightenment
 - 16 more...

ideas--
 - randomly append "Watch out for snakes!" to the end of description blurbs.
   + 1% chance, maybe? don't let refreshing the description have another
     chance though -- only once per day
    - when that happens you can hit 'w' to 'watch out for snakes' and you'll
      find a dune buggy, which you can drive around. reduces travel time
      between provinces significantly.
